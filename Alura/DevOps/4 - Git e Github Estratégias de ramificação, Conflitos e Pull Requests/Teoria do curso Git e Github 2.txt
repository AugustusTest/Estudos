Aula 01 - GitHub e OpenSource -------

	Lembrete dos 4 estágios do arquivo no Git:
	
		untracked: Não rastreado ainda pelo Git, precisa ser adicionado.
		
		unmodified: Adicionado mas sem alteração alguma.
		
		modified: Adicionado e modificado, precisa ser adicionado para commit.	
		
		stage: Pronto para ser commitado.


	Teoria:
	
		GitHub é muito utilizado pela comunidade de desenvolvimento open source (Código aberto).
		Publicamente isto envolve: Sugestão de melhorias, implementação de melhorias, solicitação de ferramentas ou recursos etc.
		Isto torna o projeto efetivamente colaborativo.
		
		Exemplos de projetos de código aberto:
		
			- VS Code (IDE)
			- NPM (Gerenciador de pacotes usado para baixar dependências do JavaScript e PHP)
		
		Código aberto a comunidade significa, muitas vezes, permitir a melhoria contínua do código de maneira colaborativa.
	
		Algumas boas funcionalidades em projetos open source são as "Issues" ou "Problemas" (Tradução Livre) que torna mais fácil controlar as sugestões de melhorias.
		
		Exemplo de projeto que utiliza Issues de forma interessante:
		
			http://github.com/phprio/cfp ou https://github.com/PHPSP/quero-palestrar/issues (Disponibilizado para cadastro de palestras ou palestrantes realizado por meio de Issues)
			
				Aqui conseguimos filtrar palestrantes através da lista de Issues do projeto.
				
				Ou seja, gerenciamos um tipo de conteúdo que não é propriamente um "problema".
				
				Lista melhorada do que podemos fazer com as "Issues":
				
					- Reportar problemas
					- Sugerir melhorias
					- Solicitar novas funcionalidades
					- Organizar qualquer coisa que faça sentido para o projeto
					- Etc
		
		Também podemos organizar as Issues por ordem de prioriadade.
		
		Para entender melhor sobre projetos OpenSource e as vantagens do GitHub neste tipo de projeto:
		
			http://slides.com/daianealvesrj/software-livre-para-empreendedores (Palestra sobre projetos OpenSource bem sucedidos de Daiane Alves no Darkmira Tour PHP 2019)
			
		Por ora, podemos citar alguns tipos de projetos OpenSouce bem sucedidos como plataformas e linguagens de programação como é o caso do PHP, .Net Core, etc.
		
		- Nunca devemos fazer alterações no GitHub diretamente, devemos criar uma cópia do projeto (Fork).
		
		- Se formos donos do repositório ou fizermos parte da organização da empresa, poderemos fechar a issue ("Close issue"), indicando que o problema já foi resolvido.
			Temos a possibilidade de reabrirmos a Issue se quisermos, informando que o problema voltou a acontecer.
		
		CRIANDO UM FORK PARA CONTRIBUIR COM ALGUM PROJETO
		
			1º - Estando logado com na conta do GitHub com a qual queremos contribuir, clicamos em "Fork" na página do projeto que desejado.
			
			2º - Criamos a pasta para alocar o projeto em nossa máquina.
			
			3º - Num primeiro momento o comando "git pull origin master" não funcionará pois o nosso diretório novo não conhece o repositório "origin".
			
		
		
		CORRIGINDO ALGUNS ERROS:
		
			Para os erros:
			
				"error: failed to push some refs to..." fazer: git commit -m "comentário do commit" Após adicionar (git add .) todos os arquivos.
				
				"error: failed to push some refs to..." fazer: git pull origin "nome do branch" --allow-unrelated-histories

				"error: cannot stat...filename too long" fazer: git config --system core.longpaths true
				
				
		EXCLUINDO DIRETÓRIOS LOCAIS GIT
		
			rm -rf .git = Exclui o diretório local do Git.
		
		
		REMOVENDO PERMISSÕES AUTOMATICAS / CORRIGINDO ERROS DE PUSH
		
			git config --local user.email "email da conta" = Adiciona o e-mail do dono do fork (Fork em referência a este curso, porém o procedimento seria o mesmo se estivessemos mudando a autenticação
							para atender outro repositório do Github).
		
			
			
			Obs: No Windows, quando utilizamos um repositório do GitHub, ele sempre tentará utilizar as credenciais utilizadas uma vez, para remove-las...
				"Painel de Controle > Contas de Usuário > Gerenciar suas Credenciais (Gerenciador de Credenciais) > Credenciais do Windows"
					Remova a credencial genérica do GitHub (Clique na seta da credencial do GitHub, para verificar todas as informações e exibir o link de remover).
			
		
		REMOVENDO AUTENTICAÇÕES SSH
		
			ls -al ~/.ssh = Lista todas as chaves.
			
			rm -f ~/.ssh/id_rsa* = Deleta os arquivos id_rsa
			
			Então posso criar uma nova chave SSH clicando em Gerar chave na janela Git GUI mostrada anteriormente...
			
		
		PULL REQUESTS (No GitHub) = Solicitações de merge com o repositório principal de alterações já realizadas no nosso Fork.
		
			Após clicar nesta área New pull request, no GitHub, ele irá verificar se o nosso Fork está "Apto para merge", se nossa branch pode ser automaticamente "mergeada" (rsrsrs)
			
			******* Na Conta dona do Repositório *******
			
				- Analisar solicitação de merge, como: Conflitos, alterações, adições etc
				
				- Clicar no botão "Merge pull request" e em seguida "Confirm merge"
					Com isso teremos um "pull Request" com o status "Merged".
					
				- Se foi a solução de uma Issue, poderemos fecha-la, junto a um texto "Fechado pelo PR #2 (Id do Pull request), clicando em "Close and comment". (PR = Pull Request).
					A Issue estará fechada e contendo o link para o último Pull request junto a todas as alterações realizadas.
					
			Obs: É bom sempre no título do nosso Pull request especificarmos exatamente qual a correção estamos realizando para que o dono do repositório possa identificar a qual Issue ela se refere (caso exista alguma), para que assim esta Issue possa ser finalmente fechada.
			
		UNIFICANDO COMMITS PARA ORGANIZAR O PULL REQUESTS
		
			O ideal é que organizemos nossos commits em apenas um para quando formos subir o nosso código em um repositório compartilhado para que o dono possa analiza-lo com mais facilidade.
			Podemos analisar nossos commits com um comando já aprendido no outro curso: git log --oneline.
			
			Podemos verificar a quantidade de commits que ainda não sofreram push para o repositório principal e realizar o comando:
				git rebase -i HEAD~"Quantidade dos ultimos commits a serem juntados"
				
				Podemos também realizar o rebase utilizando o número hash do commit anterior aos commits que desejamos trabalhar/enviar:
					git rebase -i "Hash do commit anterior aos que quero trabalhar/enviar"
					
				Após realizar o comando rebase seremos direcionados para uma tela onde os commits serão exibidos e teremos a oportunidade de definir qual sera o commit "pai" dos outros.
				Em outras palavras, um dos commits deverá absorver os outros para que se tornem um, consequentemente o comentário deste commit será aquele da resolução da Issue ou Pull Request qualquer que for enviado.
				
				 Obs: Aquele que contiver o rótulo "pick" será o commit principal, os outros que tiverem o rótulo "s" serão aqueles absorvidos por seus commits anteriores.
				 
				 Salvamos o arquivo que foi aberto com ":+x"
				 
		
		ARTIGO PARA ENTENDER MELHOR OS PULL REQUEST FECHANDO AS ISSUES COM PALAVRAS CHAVE
		
			https://help.github.com/en/articles/closing-issues-using-keywords
			
		
		ALTERNATIVAS AO GITHUB
		
			- Gitbucket: Pode ser criado repositórios públicos.
			- GitLab: Full DevOps - Gerenciar ferramentas de servidores de integração e entrega contínua.
			
			Obs: GitHub permite que o repositório seja privado para projetos com até 3 colaboradores.
			
			
		CHERRY-PICK
		
			Cherry-pick é uma forma de trazer apenas as alterações de um commit para o branch master.
			
				git cherry-pick "hash do commit desejado" = Se você quer apenas uma alteração de outra branch, informando o hash do commit em que houve a alteração, você irá traze-lá sem a necessidade de carregar todas as outras
															alterações daquele branch para master.
			
		
		ENCONTRANDO BUGS
		
			Para encontrar bugs temos a ferramenta "git bisect" que serve para "debugarmos" nosso commit indo a partir de um commit específico até a nossa "HEAD" e verificarmos onde está a alteração que procuramos.
			
				git bisect start = Inicia a ferramenta.
				
					git bisect bad "Hash do commit" = Onde estamos atualmente, em outras palavras o HEAD com o commit que não estamos satisfeitos.
				
					git bisect good "Hash do commit" = Onde irá iniciar o "debug" dos commits.
				
						git bisect bad = Enquanto não encontrar o commit desejado.
						
						git bisect good = Quando encontrar o commit desejado.
						
						git bisect reset = Para voltar para o branch master.
						
						Então, será possível usar o hash exibido para reverter alterações.
						
							git revert "Hash do commit (7 ou 8 primeiros caracteres do commit)" = Reverte as alterações indo para o commit do hash informado.
						
						Obs: É possível que haja conflitos com o nosso HEAD e a alteração que desejamos (se desejamos) trazer de volta, se isto acontecer resolva os conflitos adicione o arquivo para commit e realize o commit.
						
						Obs 2: Podemos também depois de achar o commit desejado utilizar o git show, que nos mostra todas as alterações realizadas naquele commit.
						
							git show "Hash do commit (7 ou 8 primeiros caracteres)" = Mostra todas as alterações do commit do hash informado.
		
			
	Questões:
	
		1 - Vimos no último vídeo uma funcionalidade interessante do GitHub: as issues. Com esta funcionalidade, podemos atingir alguns resultados interessantes na organização de um projeto.
		
		Sobre o que podemos fazer com issues, avalie as afirmativas abaixo:

		a) Podemos reportar problemas

		b) Podemos sugerir melhorias no código

		c) Podemos organizar quaisquer coisas que façam sentido para o projeto

		Selecione uma alternativa
		
		R: As afirmativas a, b e c estão corretas
		
		Alternativa correta! Todas as afirmativas estão corretas, já que o propósito inicial das issues, como o nome já diz, era reportar e controlar os problemas e bugs de um projeto (afirmativa a). Além disso, com o tempo, passaram a perceber que havia mais possibilidades nas issues, e elas foram utilizadas para sugestão de melhorias no projeto e pedidos de novas funcionalidades (afirmativa b). Por fim, ótimos exemplos de usos das issues no GitHub são das comunidades PHPSP e PHPRio, que as utilizam para organizar os palestrantes e sugestões de palestras (afirmativa c).
		
		
		2 - Já vimos como sugerir melhorias ou reportar problemas utilizando issues, mas o nosso trabalho no mundo Open Source pode ser mais ativo. Através de pull requests, nós podemos enviar melhorias e correções para projetos.

		Por que utilizar pull requests e não editar o projeto original?

		Selecione uma alternativa
		
		R: Para garantir a qualidade do projeto pelos seus líderes e organizadores
		
		Alternativa correta! Através de pull requests, os principais mantenedores de um projeto podem analisar todas as alterações, aprová-las ou reprová-las, dar feedback e interagir de uma forma geral. Pull requests não são utilizados apenas para projetos Open Source. Muitas equipes utilizam pull requests em seu dia-a-dia, para enviar as alterações de código para revisão de algum supervisor.
		
		
		3 - Tendo entendido o que são issues e pull requests, nada mais justo do que enviar um pull request para resolver uma issue, certo? Mas quando desenvolvemos, podemos realizar vários commits, o que pode não ser tão interessante para quem for revisar o pull request.

		Por que é interessante unir os commits em um único para enviar um pull request?

		Selecione uma alternativa
		
		R: Para que o responsável pela revisão do projeto tenha um único commit a revisar, com todas as alterações necessárias
		
		Alternativa correta! Revisar um único commit é bem mais fácil e rápido do que analisar diversos commits que resolvem um problema em comum. Por isso, nestes casos, é interessante utilizar o git rebase -i.
		
		
		4 - No último vídeo, vimos como podemos trazer um único commit específico de outra branch para a branch em que estamos trabalhando.

		Em que caso faz sentido trazer um commit específico para a branch atual?

		Selecione uma alternativa
		
		R: Quando um bug que afeta a branch atual já foi solucionado em outra branch
		
		Alternativa correta! Se uma implementação é necessária em sua branch e já foi feita em outra branch, pode fazer sentido trazer um commit específico, utilizando o git cherry-pick.
		
		
		5 - No último vídeo, nós utilizamos o git bisect para encontrar determinado ponto na história do código em que alguma alteração foi introduzida. Fizemos isso, informando os estados do commit (se estava "bom" ou "ruim").

		Para que o git bisect pode ser útil?

		Selecione uma alternativa
		
		R: Para encontrar o commit em que um bug foi introduzido

		Alternativa correta! Encontrando o exato commit em que determinado bug foi introduzido, podemos revertê-lo ou até mesmo tentar entender o motivo daquele bug ter sido introduzido.
		